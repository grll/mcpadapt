{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MCP Adapt","text":"<p>MCPadapt let you seamlessly use 1000+ MCP server \"tools\" with many agentic frameworks including HuggingFace Smolagents, crewAI, langchain, google-genai and more to come.</p> <p>MCPAdapt supports all transport protocols available in MCP, including:</p> <ul> <li>Standard I/O (stdio) for local tool execution.</li> <li>Server-Sent Events (SSE) for real-time streaming communication.</li> </ul> <p>Dependencies are efficiently managed through optional extras, allowing you to install only the frameworks you need. This means you can use MCPAdapt with your preferred framework without installing unnecessary dependencies for other frameworks that you don't use.</p>"},{"location":"#why-mcpadapt","title":"Why MCPAdapt?","text":"<p>There are dozens of agentic frameworks available today, each implementing their own Tool class with different signatures and functionality. The MCP community has developed thousands of MCP servers each with many powerful tools representing a huge opportunity for improving agents capabilities. Yet not all agentic frameworks support the MCP protocol.</p> <p>Popular MCP tool directories like glama.ai and smithery.ai showcase the vast ecosystem of tools your agents could leverage - from data analysis and web automation to complex reasoning and specialized domain tools. MCPAdapt makes it simple to unlock this potential by providing seamless integration between your preferred agent framework and any MCP server.</p>"},{"location":"#how-mcpadapt-works","title":"How MCPAdapt works?","text":"<p>MCPAdapt consists of two main components:</p> <ol> <li> <p>A core component that handles all the complexity of managing MCP server lifecycle in both synchronous and asynchronous contexts. This core functionality is shared and leveraged across the different agentic frameworks.</p> </li> <li> <p>Framework-specific adapters that transform MCP server tools into the appropriate format for each agent framework. These adapters are simple subclasses that convert MCP tools into the specific Tool classes, functions, or signatures required by frameworks like Langchain, CrewAI, or Smolagents.</p> </li> </ol> <p>This architecture allows MCPAdapt to provide consistent MCP server management while seamlessly integrating with the unique requirements of each agentic framework.</p> <p>When we can we also integrate MCPAdapt directly in the target agentic framework. This is the case for Smolagents where mcpadapt is available and directly integrated there. </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install mcpadapt[agentic-framework]\n</code></pre> <p>where agentic-framework can be:</p> <ul> <li>smolagents</li> <li>crewai</li> <li>langchain</li> <li>google-genai</li> <li>llamaindex</li> </ul>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>In the most simple case, MCP adapt takes the following form:</p> <pre><code>from mcp import StdioServerParameters\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.&lt;agentic-framework&gt;_adapter import &lt;AgenticFramework&gt;Adapter\n\nwith MCPAdapt(\n    StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]),\n    &lt;AgenticFramework&gt;Adapter(),\n) as tools:\n    # tools is a list of tools 100% compatible with your agentic framework.\n    ...\n</code></pre> <p>We also support SSE and provide detailed example for each particular framework see [link].</p>"},{"location":"#contribute","title":"Contribute","text":"<p>This project can grow bigger, support more agentic framework and more functionality with your help. We are commited to review your work, suggestion and issues quickly and carefully.</p> <p>As an example contribution, adding an adapter for a new framework is quite straight forward:</p> <ol> <li>create a new module in <code>src/mcpadapt/&lt;agentic-framework&gt;_adapter.py</code>: <pre><code>class &lt;AgenticFramework&gt;Adapter(ToolAdapter):\n    def adapt(\n        self,\n        func: Callable[[dict | None], mcp.types.CallToolResult],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; YourFramework.Tool:\n        # HERE implement how the adapter should convert a simple function and mcp_tool (JSON Schema)\n        # into your framework tool. see smolagents_adapter.py for an example\n\n    def async_adapt(\n        self,\n        afunc: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; YourFramework.Tool:\n        # if your framework supports async function even better use async_adapt.\n</code></pre></li> <li>add test, documentation and submit your PR for review.</li> </ol>"},{"location":"#contributors","title":"Contributors","text":"<p>We acknowledge the work and thanks every contributors and maintainers for their contributions.</p> <p>Core Maintainers:</p> <ul> <li>@grll</li> </ul> <p>Contributors:</p> <ul> <li>@murawakimitsuhiro</li> <li>@joejoe2</li> <li>@tisDDM</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>Install mcpadapt for your agentic framework of choice with:</p> <pre><code>pip install mcpadapt[agentic-framework]\n</code></pre> <p>where agentic-framework can be:</p> <ul> <li>smolagents</li> <li>crewai</li> <li>langchain</li> <li>google-genai</li> <li>llamaindex</li> </ul>"},{"location":"quickstart/#usage","title":"Usage","text":""},{"location":"quickstart/#standard-io-stdio","title":"Standard IO (stdio)","text":"<p>In the most simple case, MCP adapt takes the following form:</p> <pre><code>from mcp import StdioServerParameters\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.&lt;agentic-framework&gt;_adapter import &lt;AgenticFramework&gt;Adapter\n\nwith MCPAdapt(\n    StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]),\n    &lt;AgenticFramework&gt;Adapter(),\n) as tools:\n    # tools is a list of tools 100% compatible with your agentic framework.\n    ...\n</code></pre> <p>In this setup:</p> <ol> <li>You define your MCP server parameters using the official Python SDK</li> <li>You import the MCPAdapt core and the appropriate adapter for your agentic framework</li> <li>You wrap your agent's code within the MCPAdapt context manager</li> </ol> <p>Behind the scenes, MCPAdapt launches your MCP server in a subprocess and handles all communication between your agentic framework and the MCP server. When your agent uses a tool, MCPAdapt transparently routes the call to the corresponding MCP server tool and returns the results in your framework's expected format.</p> <p>If your agentic framework support async then you can also use MCPAdapt with async:</p> <pre><code>from mcp import StdioServerParameters\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.&lt;agentic-framework&gt;_adapter import &lt;AgenticFramework&gt;Adapter\n\nasync with MCPAdapt(\n    StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]),\n    &lt;AgenticFramework&gt;Adapter(),\n) as tools:\n    # tools is a list of tools 100% compatible with your agentic framework.\n    ...\n</code></pre>"},{"location":"quickstart/#sse-server-sent-events-support","title":"SSE (Server-Sent Events) Support","text":"<p>MCPAdapt supports SSE for both synchronous and asynchronous operations. Here's how to use it:</p> <pre><code>from mcpadapt.core import MCPAdapt\nfrom mcpadapt.&lt;framework&gt;_adapter import &lt;Framework&gt;Adapter\n\nasync with MCPAdapt(\n    {\n        \"url\": \"http://127.0.0.1:8000/sse\",\n        # Optional parameters:\n        # \"headers\": {\"Authorization\": \"Bearer token\"},\n        # \"timeout\": 5,  # Connection timeout in seconds\n        # \"sse_read_timeout\": 300  # SSE read timeout in seconds (default: 5 minutes)\n    },\n    &lt;Framework&gt;Adapter()\n) as tools:\n    # 'tools' contains framework-compatible tools\n    ...\n</code></pre> <p>To use SSE, simply provide a configuration dictionary instead of StdioServerParameters. The configuration accepts the following parameters:</p> Parameter Type Required Default Description url str Yes - The SSE endpoint URL headers dict[str, Any] No None Custom HTTP headers timeout float No 5 Connection timeout in seconds sse_read_timeout float No 300 SSE read timeout in seconds <p>These parameters are passed directly to the MCP Python SDK's SSE client. For more details, see the official MCP Python SDK documentation.</p>"},{"location":"quickstart/#examples","title":"Examples","text":"<p>We provide guided examples of usage for each framework in their respective guides:</p> <ul> <li>SmolAgents Guide</li> <li>CrewAI Guide</li> <li>LangChain Guide</li> <li>Google GenAI Guide</li> </ul>"},{"location":"guide/crewai/","title":"CrewAI","text":"<p>At the time of writing, MCPAdapt offers integration with CrewAI through its adapter system only. However a PR is underway to integrate directly into CrewAI's framework.</p> <p>Let's explore how to use MCPAdapt with CrewAI.</p>"},{"location":"guide/crewai/#using-mcpadapt-crewai-adapter","title":"Using MCPAdapt CrewAI Adapter","text":"<p>Ensure you have the necessary dependencies installed and set up your OpenAI API key as required by crewAI:</p> <pre><code>pip install mcpadapt[crewai]\n</code></pre>"},{"location":"guide/crewai/#creating-a-simple-echo-server","title":"Creating a Simple Echo Server","text":"<p>First, create an MCP server using FastMCP notation:</p> <pre><code># echo.py\nfrom mcp.server.fastmcp import FastMCP\nfrom pydantic import Field\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n\n@mcp.tool()\ndef echo_tool(text: str = Field(description=\"The text to echo\")) -&gt; str:\n    \"\"\"Echo the input text\n\n    Args:\n        text (str): The text to echo\n\n    Returns:\n        str: The echoed text\n    \"\"\"\n    return text\n\nmcp.run()\n</code></pre>"},{"location":"guide/crewai/#using-the-echo-server","title":"Using the Echo Server","text":"<p>Here's how to interact with the server using CrewAI:</p> <pre><code>import os\nfrom crewai import Agent, Crew, Task\nfrom mcp import StdioServerParameters\n\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.crewai_adapter import CrewAIAdapter\n\nwith MCPAdapt(\n    StdioServerParameters(command=\"uv\", args=[\"run\", \"echo.py\"]),\n    CrewAIAdapter(),\n) as tools:\n    # Create an echo agent\n    agent = Agent(\n        role=\"Echo Agent\",\n        goal=\"Echo messages back to the user\",\n        backstory=\"You help echo messages back to users\",\n        verbose=True,\n        tools=[tools[0]],\n    )\n\n    # Create a task\n    task = Task(\n        description=\"Echo 'Hello, World!'\",\n        agent=agent,\n        expected_output=\"The echoed message\",\n    )\n\n    # Create and run the crew\n    crew = Crew(agents=[agent], tasks=[task], verbose=True)\n    crew.kickoff()\n</code></pre>"},{"location":"guide/crewai/#real-world-example-pubmed-mcp-server","title":"Real-World Example: PubMed MCP Server","text":"<p>In the real-world, you are most likely to run MCP server already built by the community. As an example, here's how to use the PubMed MCP server with CrewAI:</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Crew, Task\nfrom mcp import StdioServerParameters\n\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.crewai_adapter import CrewAIAdapter\n\n# Load environment variables\nload_dotenv()\nif not os.environ.get(\"OPENAI_API_KEY\"):\n    raise ValueError(\"OPENAI_API_KEY must be set in your environment variables\")\n\n# Initialize MCPAdapt with CrewAI adapter\nwith MCPAdapt(\n    StdioServerParameters(\n        command=\"uvx\",\n        args=[\"--quiet\", \"pubmedmcp@0.1.3\"],\n        env={\"UV_PYTHON\": \"3.12\", **os.environ},\n    ),\n    CrewAIAdapter(),\n) as tools:\n    # Create a research agent\n    agent = Agent(\n        role=\"Research Agent\",\n        goal=\"Find studies about hangover\",\n        backstory=\"You help find studies about hangover\",\n        verbose=True,\n        tools=[tools[0]],\n    )\n\n    # Create a task\n    task = Task(\n        description=\"Find studies about hangover\",\n        agent=agent,\n        expected_output=\"A list of studies about hangover\",\n    )\n\n    # Create and run the crew\n    crew = Crew(agents=[agent], tasks=[task], verbose=True)\n    crew.kickoff()\n</code></pre>"},{"location":"guide/crewai/#important-notes","title":"Important Notes:","text":"<ul> <li>Always use the <code>--quiet</code> flag with uvx to prevent output interference with the stdio transport protocol</li> <li>Including <code>**os.environ</code> helps resolve paths in the subprocess but consider security implications of sending your environment variables to the MCP server</li> <li>Remote MCP servers are supported via Server Sent Events (SSE). See the quickstart SSE guide</li> <li>Make sure to set your OPENAI_API_KEY in your environment variables or .env file</li> </ul>"},{"location":"guide/crewai/#full-working-code-example","title":"Full Working Code Example","text":"<p>You can find a fully working script of this example here</p>"},{"location":"guide/google-genai/","title":"Google GenAI","text":"<p>MCPAdapt offers integration with Google's genai SDK through its adapter system. Let's explore how to use MCPAdapt with Google GenAI.</p>"},{"location":"guide/google-genai/#using-mcpadapt-google-genai-adapter","title":"Using MCPAdapt Google GenAI Adapter","text":"<p>First, ensure you have the necessary dependencies installed:</p> <pre><code>pip install mcpadapt[google-genai]\n</code></pre> <p>You'll also need to set up your Google API key. You can get this from the Google AI Studio.</p>"},{"location":"guide/google-genai/#creating-a-simple-echo-server","title":"Creating a Simple Echo Server","text":"<p>First, let's create an MCP server using FastMCP notation:</p> <pre><code># echo.py\nfrom mcp.server.fastmcp import FastMCP\nfrom pydantic import Field\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n@mcp.tool()\ndef echo_tool(text: str = Field(description=\"The text to echo\")) -&gt; str:\n    \"\"\"Echo the input text\n\n    Args:\n        text (str): The text to echo\n\n    Returns:\n        str: The echoed text\n    \"\"\"\n    return text\n\nmcp.run()\n</code></pre>"},{"location":"guide/google-genai/#using-the-echo-server-with-google-genai","title":"Using the Echo Server with Google GenAI","text":"<p>Here's how to interact with the server using Google's Generative AI:</p> <pre><code>import os\nfrom google import genai\nfrom google.genai import types\nfrom mcp import StdioServerParameters\n\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.google_genai_adapter import GoogleGenAIAdapter\n\n# Initialize Google GenAI client\nclient = genai.Client(api_key=os.getenv(\"GEMINI_API_KEY\"))\n\n# Create server parameters\nserver_params = StdioServerParameters(\n    command=\"uv\",\n    args=[\"run\", \"echo.py\"]\n)\n\nasync def run():\n    async with MCPAdapt(\n        server_params,\n        GoogleGenAIAdapter(),\n    ) as adapted_tools:\n        # Unpack tools and tool_functions\n        google_tools, tool_functions = zip(*adapted_tools)\n        tool_functions = dict(tool_functions)\n\n        prompt = \"Please echo back 'Hello, World!'\"\n\n        # Generate content with function declarations\n        response = client.models.generate_content(\n            model=\"gemini-2.0-flash\",\n            contents=prompt,\n            config=types.GenerateContentConfig(\n                temperature=0.7,\n                tools=google_tools,\n            ),\n        )\n\n        # Handle the function call\n        if response.candidates[0].content.parts[0].function_call:\n            function_call = response.candidates[0].content.parts[0].function_call\n            result = await tool_functions[function_call.name](function_call.args)\n            print(result.content[0].text)\n        else:\n            print(\"No function call found in the response.\")\n            print(response.text)\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(run())\n</code></pre>"},{"location":"guide/google-genai/#real-world-example-airbnb-mcp-server","title":"Real-World Example: Airbnb MCP Server","text":"<p>Here's a real-world example using the Airbnb MCP server with Google GenAI:</p> <pre><code>import os\nfrom google import genai\nfrom google.genai import types\nfrom mcp import StdioServerParameters\n\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.google_genai_adapter import GoogleGenAIAdapter\n\n# Initialize Google GenAI client\nclient = genai.Client(api_key=os.getenv(\"GEMINI_API_KEY\"))\n\n# Create server parameters for Airbnb MCP\nserver_params = StdioServerParameters(\n    command=\"npx\",\n    args=[\n        \"-y\",\n        \"@openbnb/mcp-server-airbnb\",\n        \"--ignore-robots-txt\",\n    ],\n)\n\nasync def run():\n    async with MCPAdapt(\n        server_params,\n        GoogleGenAIAdapter(),\n    ) as adapted_tools:\n        # Unpack tools and tool_functions\n        google_tools, tool_functions = zip(*adapted_tools)\n        tool_functions = dict(tool_functions)\n\n        prompt = \"I want to book an apartment in Paris for 2 nights, March 28-30\"\n\n        # Generate content with function declarations\n        response = client.models.generate_content(\n            model=\"gemini-2.0-flash\",\n            contents=prompt,\n            config=types.GenerateContentConfig(\n                temperature=0.7,\n                tools=google_tools,\n            ),\n        )\n\n        # Handle the function call\n        if response.candidates[0].content.parts[0].function_call:\n            function_call = response.candidates[0].content.parts[0].function_call\n            result = await tool_functions[function_call.name](function_call.args)\n            print(result.content[0].text)\n        else:\n            print(\"No function call found in the response.\")\n            print(response.text)\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(run())\n</code></pre>"},{"location":"guide/google-genai/#important-notes","title":"Important Notes:","text":"<ul> <li>Make sure to set your <code>GEMINI_API_KEY</code> in your environment variables</li> <li>The examples work with both synchronous and asynchronous code</li> <li>Remote MCP servers are supported via Server Sent Events (SSE). See the quickstart SSE guide</li> </ul>"},{"location":"guide/google-genai/#full-working-code-example","title":"Full Working Code Example","text":"<p>You can find a fully working script of the Airbnb example here</p>"},{"location":"guide/langchain/","title":"Langchain","text":"<p>MCPAdapt offers integration with LangChain through its adapter system. Let's explore how to use MCPAdapt with LangChain.</p>"},{"location":"guide/langchain/#using-mcpadapt-langchain-adapter","title":"Using MCPAdapt LangChain Adapter","text":"<p>First, ensure you have the necessary dependencies installed:</p> <pre><code>pip install mcpadapt[langchain]\n</code></pre>"},{"location":"guide/langchain/#creating-a-simple-echo-server","title":"Creating a Simple Echo Server","text":"<p>Let's start with a basic example using a simple echo server:</p> <pre><code># echo.py\nfrom mcp.server.fastmcp import FastMCP\nfrom pydantic import Field\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n@mcp.tool()\ndef echo_tool(text: str = Field(description=\"The text to echo\")) -&gt; str:\n    \"\"\"Echo the input text\n\n    Args:\n        text (str): The text to echo\n\n    Returns:\n        str: The echoed text\n    \"\"\"\n    return text\n\nmcp.run()\n</code></pre>"},{"location":"guide/langchain/#using-the-echo-server-with-langchain","title":"Using the Echo Server with LangChain","text":"<p>Here's how to interact with the server using LangChain:</p> <pre><code>import os\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_core.messages import HumanMessage\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.prebuilt import create_react_agent\nfrom mcp import StdioServerParameters\n\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.langchain_adapter import LangChainAdapter\n\n# Initialize MCPAdapt with LangChain adapter\nasync with MCPAdapt(\n    StdioServerParameters(command=\"uv\", args=[\"run\", \"echo.py\"]),\n    LangChainAdapter(),\n) as tools:\n    # Create the agent\n    memory = MemorySaver()\n    model = ChatAnthropic(\n        model_name=\"claude-3-5-sonnet-20241022\",\n        max_tokens_to_sample=8192\n    )\n    agent_executor = create_react_agent(model, tools, checkpointer=memory)\n\n    # Use the agent\n    config = {\"configurable\": {\"thread_id\": \"abc123\"}}\n    async for event in agent_executor.astream(\n        {\n            \"messages\": [\n                HumanMessage(content=\"Echo 'Hello, World!'\")\n            ]\n        },\n        config,\n    ):\n        print(event)\n        print(\"----\")\n</code></pre>"},{"location":"guide/langchain/#real-world-example-pubmed-mcp-server","title":"Real-World Example: PubMed MCP Server","text":"<p>In reality you are more likely to use MCP servers defined by the community. Here's how to use the PubMed MCP server with LangChain for a more practical example:</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_core.messages import HumanMessage\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.prebuilt import create_react_agent\nfrom mcp import StdioServerParameters\n\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.langchain_adapter import LangChainAdapter\n\n# Load environment variables\nload_dotenv()\nif not os.environ.get(\"ANTHROPIC_API_KEY\"):\n    raise ValueError(\"ANTHROPIC_API_KEY must be set in your environment variables\")\n\nasync with MCPAdapt(\n    StdioServerParameters(\n        command=\"uvx\",\n        args=[\"--quiet\", \"pubmedmcp@0.1.3\"],\n        env={\"UV_PYTHON\": \"3.12\", **os.environ},\n    ),\n    LangChainAdapter(),\n) as tools:\n    # Create the agent\n    memory = MemorySaver()\n    model = ChatAnthropic(\n        model_name=\"claude-3-5-sonnet-20241022\",\n        max_tokens_to_sample=8192\n    )\n    agent_executor = create_react_agent(model, tools, checkpointer=memory)\n\n    # Use the agent\n    config = {\"configurable\": {\"thread_id\": \"abc123\"}}\n    async for event in agent_executor.astream(\n        {\n            \"messages\": [\n                HumanMessage(\n                    content=\"Find relevant studies on alcohol hangover and treatment.\"\n                )\n            ]\n        },\n        config,\n    ):\n        print(event)\n        print(\"----\")\n</code></pre>"},{"location":"guide/langchain/#important-notes","title":"Important Notes:","text":"<ul> <li>Always use the <code>--quiet</code> flag with uvx to prevent output interference with the stdio transport protocol</li> <li>Including <code>**os.environ</code> helps resolve paths in the subprocess but consider security implications</li> <li>Remote MCP servers are supported via Server Sent Events (SSE). See the quickstart SSE guide</li> <li>Make sure to set your ANTHROPIC_API_KEY in your environment variables or .env file</li> <li>The examples use Claude 3.5 Sonnet, but you can use any LangChain-compatible model</li> <li>Both synchronous and asynchronous implementations are supported, but async is preferred for better performance</li> </ul>"},{"location":"guide/langchain/#full-working-code-example","title":"Full Working Code Example","text":"<p>You can find a fully working script of this example here</p>"},{"location":"guide/smolagents/","title":"Smolagents","text":"<p>MCPAdapt offers two ways to integrate with HuggingFace Smolagents. Let's explore both options:</p>"},{"location":"guide/smolagents/#option-1-direct-smolagents-integration","title":"Option 1: Direct Smolagents Integration","text":"<p>Install the package with MCP support:</p> <pre><code>pip install smolagents[mcp]\n</code></pre>"},{"location":"guide/smolagents/#creating-a-simple-echo-server","title":"Creating a Simple Echo Server","text":"<p>First, create an MCP server using FastMCP notation (from the official python-sdk):</p> <pre><code># echo.py\nfrom mcp.server.fastmcp import FastMCP\nfrom pydantic import Field\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n\n@mcp.tool()\ndef echo_tool(text: str = Field(description=\"The text to echo\")) -&gt; str:\n    \"\"\"Echo the input text\n\n    Args:\n        text (str): The text to echo\n\n    Returns:\n        str: The echoed text\n    \"\"\"\n    return text\n\nmcp.run()\n</code></pre>"},{"location":"guide/smolagents/#using-the-echo-server","title":"Using the Echo Server","text":"<p>Here's how to interact with the server:</p> <pre><code>from mcp import StdioServerParameters\nfrom smolagents import CodeAgent, HfApiModel  # type: ignore\nfrom smolagents.tools import ToolCollection\n\nserverparams = StdioServerParameters(command=\"uv\", args=[\"run\", \"echo.py\"])\n\nwith ToolCollection.from_mcp(serverparams) as tool_collection:\n    agent = CodeAgent(tools=tools, model=HfApiModel())\n    agent.run(\"Can you echo something?\")\n</code></pre>"},{"location":"guide/smolagents/#real-world-example-pubmed-mcp-server","title":"Real-World Example: PubMed MCP Server","text":"<p>Most often, you'll use pre-built MCP servers. Here's an example using the PubMed MCP server:</p> <pre><code>import os\n\nfrom mcp import StdioServerParameters\nfrom smolagents import CodeAgent, HfApiModel  # type: ignore\nfrom smolagents.tools import ToolCollection\n\nwith ToolCollection.from_mcp(\n    StdioServerParameters(\n        command=\"uvx\",\n        args=[\"--quiet\", \"pubmedmcp@0.1.3\"],\n        env={\"UV_PYTHON\": \"3.12\", **os.environ},\n    ),\n) as tools:\n    # print(tools[0](request={\"term\": \"efficient treatment hangover\"}))\n    agent = CodeAgent(tools=tools, model=HfApiModel())\n    agent.run(\"Find studies about hangover?\")\n</code></pre>"},{"location":"guide/smolagents/#important-notes","title":"Important Notes:","text":"<ul> <li>Always use the <code>--quiet</code> flag with uvx to prevent output interference with the stdio transport protocol</li> <li>Including <code>**os.environ</code> helps resolve paths in the subprocess but consider security implications of sending your environment variable to the MCP server.</li> <li>Remote MCP servers are supported via Server Sent Events (SSE). See the quickstart SSE guide</li> </ul>"},{"location":"guide/smolagents/#option-2-mcpadapt-smolagents-adapter","title":"Option 2: MCPAdapt Smolagents Adapter","text":"<p>Alternatively, you can use the MCPAdapt smolagents adapter:</p> <pre><code>import os\n\nfrom mcp import StdioServerParameters\nfrom smolagents import CodeAgent, HfApiModel  # type: ignore\n\nfrom mcpadapt.core import MCPAdapt\nfrom mcpadapt.smolagents_adapter import SmolAgentsAdapter\n\nwith MCPAdapt(\n    StdioServerParameters(\n        command=\"uvx\",\n        args=[\"--quiet\", \"pubmedmcp@0.1.3\"],\n        env={\"UV_PYTHON\": \"3.12\", **os.environ},\n    ),\n    SmolAgentsAdapter(),\n) as tools:\n    agent = CodeAgent(tools=tools, model=HfApiModel())\n    agent.run(\"Find studies about hangover?\")\n</code></pre> <p>This approach achieves the same result but uses MCPAdapt directly with its smolagents adapter.</p>"},{"location":"guide/smolagents/#full-working-code-example","title":"Full Working Code Example","text":"<p>You a fully working script of this example here</p>"},{"location":"ref/core/","title":"<code>Core</code>","text":"<p>Core module for the MCPAdapt library.</p> <p>This module contains the core functionality for the MCPAdapt library. It provides the basic interfaces and classes for adapting tools from MCP to the desired Agent framework.</p>"},{"location":"ref/core/#mcpadapt.core.ToolAdapter","title":"ToolAdapter","text":"<p>               Bases: <code>ABC</code></p> <p>A basic interface for adapting tools from MCP to the desired Agent framework.</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>class ToolAdapter(ABC):\n    \"\"\"A basic interface for adapting tools from MCP to the desired Agent framework.\"\"\"\n\n    @abstractmethod\n    def adapt(\n        self,\n        func: Callable[[dict | None], mcp.types.CallToolResult],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; Any:\n        \"\"\"Adapt a single tool from MCP to the desired Agent framework.\n\n        The MCP protocol will provide a name, description and inputSchema in JSON Schema\n        format. This needs to be adapted to the desired Agent framework.\n\n        Note that the function is synchronous (not a coroutine) you can use\n        :meth:`ToolAdapter.async_adapt` if you need to use the tool asynchronously.\n\n        Args:\n            func: The function to be called (will call the tool via the MCP protocol).\n            mcp_tool: The tool to adapt.\n\n        Returns:\n            The adapted tool in the agentic framework of choice.\n        \"\"\"\n        pass\n\n    def async_adapt(\n        self,\n        afunc: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; Any:\n        \"\"\"Adapt a single tool from MCP to the desired Agent framework.\n\n        The MCP protocol will provide a name, description and inputSchema in JSON Schema\n        format. This needs to be adapted to the desired Agent framework.\n\n        Note that the function is asynchronous (a coroutine) you can use\n        :meth:`ToolAdapter.adapt` if you need to use the tool synchronously.\n\n        Args:\n            afunc: The coroutine to be called.\n            mcp_tool: The tool to adapt.\n\n        Returns:\n            The adapted tool in the agentic framework of choice.\n        \"\"\"\n        raise NotImplementedError(\n            \"Async adaptation is not supported for this Agent framework.\"\n        )\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.ToolAdapter.adapt","title":"adapt  <code>abstractmethod</code>","text":"<pre><code>adapt(\n    func: Callable[[dict | None], CallToolResult],\n    mcp_tool: Tool,\n) -&gt; Any\n</code></pre> <p>Adapt a single tool from MCP to the desired Agent framework.</p> <p>The MCP protocol will provide a name, description and inputSchema in JSON Schema format. This needs to be adapted to the desired Agent framework.</p> <p>Note that the function is synchronous (not a coroutine) you can use :meth:<code>ToolAdapter.async_adapt</code> if you need to use the tool asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict | None], CallToolResult]</code> <p>The function to be called (will call the tool via the MCP protocol).</p> required <code>mcp_tool</code> <code>Tool</code> <p>The tool to adapt.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The adapted tool in the agentic framework of choice.</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>@abstractmethod\ndef adapt(\n    self,\n    func: Callable[[dict | None], mcp.types.CallToolResult],\n    mcp_tool: mcp.types.Tool,\n) -&gt; Any:\n    \"\"\"Adapt a single tool from MCP to the desired Agent framework.\n\n    The MCP protocol will provide a name, description and inputSchema in JSON Schema\n    format. This needs to be adapted to the desired Agent framework.\n\n    Note that the function is synchronous (not a coroutine) you can use\n    :meth:`ToolAdapter.async_adapt` if you need to use the tool asynchronously.\n\n    Args:\n        func: The function to be called (will call the tool via the MCP protocol).\n        mcp_tool: The tool to adapt.\n\n    Returns:\n        The adapted tool in the agentic framework of choice.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.ToolAdapter.async_adapt","title":"async_adapt","text":"<pre><code>async_adapt(\n    afunc: Callable[\n        [dict | None], Coroutine[Any, Any, CallToolResult]\n    ],\n    mcp_tool: Tool,\n) -&gt; Any\n</code></pre> <p>Adapt a single tool from MCP to the desired Agent framework.</p> <p>The MCP protocol will provide a name, description and inputSchema in JSON Schema format. This needs to be adapted to the desired Agent framework.</p> <p>Note that the function is asynchronous (a coroutine) you can use :meth:<code>ToolAdapter.adapt</code> if you need to use the tool synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>afunc</code> <code>Callable[[dict | None], Coroutine[Any, Any, CallToolResult]]</code> <p>The coroutine to be called.</p> required <code>mcp_tool</code> <code>Tool</code> <p>The tool to adapt.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The adapted tool in the agentic framework of choice.</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>def async_adapt(\n    self,\n    afunc: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n    mcp_tool: mcp.types.Tool,\n) -&gt; Any:\n    \"\"\"Adapt a single tool from MCP to the desired Agent framework.\n\n    The MCP protocol will provide a name, description and inputSchema in JSON Schema\n    format. This needs to be adapted to the desired Agent framework.\n\n    Note that the function is asynchronous (a coroutine) you can use\n    :meth:`ToolAdapter.adapt` if you need to use the tool synchronously.\n\n    Args:\n        afunc: The coroutine to be called.\n        mcp_tool: The tool to adapt.\n\n    Returns:\n        The adapted tool in the agentic framework of choice.\n    \"\"\"\n    raise NotImplementedError(\n        \"Async adaptation is not supported for this Agent framework.\"\n    )\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt","title":"MCPAdapt","text":"<p>The main class for adapting MCP tools to the desired Agent framework.</p> <p>This class can be used either as a sync or async context manager.</p> <p>If running synchronously, it will run the MCP server in a separate thread and take care of making the tools synchronous without blocking the server.</p> <p>If running asynchronously, it will use the async context manager and return async tools.</p> <p>Dependening on what your Agent framework supports choose the approriate method. If async is supported it is recommended.</p> <p>Important Note: adapters need to implement the async_adapt method to support async tools.</p> <p>Usage:</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>class MCPAdapt:\n    \"\"\"The main class for adapting MCP tools to the desired Agent framework.\n\n    This class can be used either as a sync or async context manager.\n\n    If running synchronously, it will run the MCP server in a separate thread and take\n    care of making the tools synchronous without blocking the server.\n\n    If running asynchronously, it will use the async context manager and return async\n    tools.\n\n    Dependening on what your Agent framework supports choose the approriate method. If\n    async is supported it is recommended.\n\n    Important Note: adapters need to implement the async_adapt method to support async\n    tools.\n\n    Usage:\n    &gt;&gt;&gt; # sync usage\n    &gt;&gt;&gt; with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), SmolAgentAdapter()) as tools:\n    &gt;&gt;&gt;     print(tools)\n\n    &gt;&gt;&gt; # async usage\n    &gt;&gt;&gt; async with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), SmolAgentAdapter()) as tools:\n    &gt;&gt;&gt;     print(tools)\n\n    &gt;&gt;&gt; # async usage with sse\n    &gt;&gt;&gt; async with MCPAdapt({\"host\": \"127.0.0.1\", \"port\": 8000}, SmolAgentAdapter()) as tools:\n    &gt;&gt;&gt;     print(tools)\n    \"\"\"\n\n    def __init__(\n        self,\n        serverparams: StdioServerParameters | dict[str, Any],\n        adapter: ToolAdapter,\n        connect_timeout: int = 30,\n    ):\n        \"\"\"\n        Manage the MCP server / client lifecycle and expose tools adapted with the adapter.\n\n        Args:\n            serverparams (StdioServerParameters | dict[str, Any]): MCP server parameters (stdio or sse).\n            adapter (ToolAdapter): Adapter to use to convert MCP tools call into agentic framework tools.\n            connect_timeout (int): Connection timeout in seconds to the mcp server (default is 30s).\n\n        Raises:\n            TimeoutError: When the connection to the mcp server time out.\n        \"\"\"\n        # attributes we receive from the user.\n        self.serverparams = serverparams\n        self.adapter = adapter\n\n        # session and tools get set by the async loop during initialization.\n        self.session: ClientSession | None = None\n        self.mcp_tools: list[mcp.types.Tool] | None = None\n\n        # all attributes used to manage the async loop and separate thread.\n        self.loop = asyncio.new_event_loop()\n        self.task = None\n        self.ready = threading.Event()\n        self.thread = threading.Thread(target=self._run_loop, daemon=True)\n\n        # start the loop in a separate thread and wait till ready synchronously.\n        self.thread.start()\n        # check connection to mcp server is ready\n        if not self.ready.wait(timeout=connect_timeout):\n            raise TimeoutError(\n                f\"Couldn't connect to the MCP server after {connect_timeout} seconds\"\n            )\n\n    def _run_loop(self):\n        \"\"\"Runs the event loop in a separate thread (for synchronous usage).\"\"\"\n        asyncio.set_event_loop(self.loop)\n\n        async def setup():\n            async with mcptools(self.serverparams) as (session, tools):\n                self.session, self.mcp_tools = session, tools\n                self.ready.set()  # Signal initialization is complete\n                await asyncio.Event().wait()  # Keep session alive until stopped\n\n        self.task = self.loop.create_task(setup())\n        try:\n            self.loop.run_until_complete(self.task)\n        except asyncio.CancelledError:\n            pass\n\n    def tools(self) -&gt; list[Any]:\n        \"\"\"Returns the tools from the MCP server adapted to the desired Agent framework.\n\n        This is what is yielded if used as a context manager otherwise you can access it\n        directly via this method.\n\n        An equivalent async method is available if your Agent framework supports it:\n        see :meth:`atools`.\n\n        \"\"\"\n        if not self.session:\n            raise RuntimeError(\"Session not initialized\")\n\n        def _sync_call_tool(\n            name: str, arguments: dict | None = None\n        ) -&gt; mcp.types.CallToolResult:\n            return asyncio.run_coroutine_threadsafe(\n                self.session.call_tool(name, arguments), self.loop\n            ).result()\n\n        return [\n            self.adapter.adapt(partial(_sync_call_tool, tool.name), tool)\n            for tool in self.mcp_tools\n        ]\n\n    def close(self):\n        \"\"\"Clean up resources and stop the client.\"\"\"\n        if self.task and not self.task.done():\n            self.loop.call_soon_threadsafe(self.task.cancel)\n        self.thread.join()  # will wait until the task is cancelled to join thread (as it's blocked Event().wait())\n        self.loop.close()  # we won't be using the loop anymore we can safely close it\n\n    def __enter__(self):\n        return self.tools()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    # -- add support for async context manager as well if the agent framework supports it.\n    def atools(self) -&gt; list[Any]:\n        \"\"\"Returns the tools from the MCP server adapted to the desired Agent framework.\n\n        This is what is yielded if used as an async context manager otherwise you can\n        access it directly via this method.\n\n        An equivalent async method is available if your Agent framework supports it:\n        see :meth:`atools`.\n        \"\"\"\n        return [\n            self.adapter.async_adapt(partial(self.session.call_tool, tool.name), tool)\n            for tool in self.mcp_tools\n        ]\n\n    async def __aenter__(self) -&gt; list[Any]:\n        self._ctxmanager = mcptools(self.serverparams)\n        self.session, self.tools = await self._ctxmanager.__aenter__()\n        return self.atools()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self._ctxmanager.__aexit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt--sync-usage","title":"sync usage","text":"<p>with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), SmolAgentAdapter()) as tools:     print(tools)</p>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt--async-usage","title":"async usage","text":"<p>async with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), SmolAgentAdapter()) as tools:     print(tools)</p>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt--async-usage-with-sse","title":"async usage with sse","text":"<p>async with MCPAdapt({\"host\": \"127.0.0.1\", \"port\": 8000}, SmolAgentAdapter()) as tools:     print(tools)</p>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt.__init__","title":"__init__","text":"<pre><code>__init__(\n    serverparams: StdioServerParameters | dict[str, Any],\n    adapter: ToolAdapter,\n    connect_timeout: int = 30,\n)\n</code></pre> <p>Manage the MCP server / client lifecycle and expose tools adapted with the adapter.</p> <p>Parameters:</p> Name Type Description Default <code>serverparams</code> <code>StdioServerParameters | dict[str, Any]</code> <p>MCP server parameters (stdio or sse).</p> required <code>adapter</code> <code>ToolAdapter</code> <p>Adapter to use to convert MCP tools call into agentic framework tools.</p> required <code>connect_timeout</code> <code>int</code> <p>Connection timeout in seconds to the mcp server (default is 30s).</p> <code>30</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>When the connection to the mcp server time out.</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>def __init__(\n    self,\n    serverparams: StdioServerParameters | dict[str, Any],\n    adapter: ToolAdapter,\n    connect_timeout: int = 30,\n):\n    \"\"\"\n    Manage the MCP server / client lifecycle and expose tools adapted with the adapter.\n\n    Args:\n        serverparams (StdioServerParameters | dict[str, Any]): MCP server parameters (stdio or sse).\n        adapter (ToolAdapter): Adapter to use to convert MCP tools call into agentic framework tools.\n        connect_timeout (int): Connection timeout in seconds to the mcp server (default is 30s).\n\n    Raises:\n        TimeoutError: When the connection to the mcp server time out.\n    \"\"\"\n    # attributes we receive from the user.\n    self.serverparams = serverparams\n    self.adapter = adapter\n\n    # session and tools get set by the async loop during initialization.\n    self.session: ClientSession | None = None\n    self.mcp_tools: list[mcp.types.Tool] | None = None\n\n    # all attributes used to manage the async loop and separate thread.\n    self.loop = asyncio.new_event_loop()\n    self.task = None\n    self.ready = threading.Event()\n    self.thread = threading.Thread(target=self._run_loop, daemon=True)\n\n    # start the loop in a separate thread and wait till ready synchronously.\n    self.thread.start()\n    # check connection to mcp server is ready\n    if not self.ready.wait(timeout=connect_timeout):\n        raise TimeoutError(\n            f\"Couldn't connect to the MCP server after {connect_timeout} seconds\"\n        )\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt.tools","title":"tools","text":"<pre><code>tools() -&gt; list[Any]\n</code></pre> <p>Returns the tools from the MCP server adapted to the desired Agent framework.</p> <p>This is what is yielded if used as a context manager otherwise you can access it directly via this method.</p> <p>An equivalent async method is available if your Agent framework supports it: see :meth:<code>atools</code>.</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>def tools(self) -&gt; list[Any]:\n    \"\"\"Returns the tools from the MCP server adapted to the desired Agent framework.\n\n    This is what is yielded if used as a context manager otherwise you can access it\n    directly via this method.\n\n    An equivalent async method is available if your Agent framework supports it:\n    see :meth:`atools`.\n\n    \"\"\"\n    if not self.session:\n        raise RuntimeError(\"Session not initialized\")\n\n    def _sync_call_tool(\n        name: str, arguments: dict | None = None\n    ) -&gt; mcp.types.CallToolResult:\n        return asyncio.run_coroutine_threadsafe(\n            self.session.call_tool(name, arguments), self.loop\n        ).result()\n\n    return [\n        self.adapter.adapt(partial(_sync_call_tool, tool.name), tool)\n        for tool in self.mcp_tools\n    ]\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Clean up resources and stop the client.</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>def close(self):\n    \"\"\"Clean up resources and stop the client.\"\"\"\n    if self.task and not self.task.done():\n        self.loop.call_soon_threadsafe(self.task.cancel)\n    self.thread.join()  # will wait until the task is cancelled to join thread (as it's blocked Event().wait())\n    self.loop.close()  # we won't be using the loop anymore we can safely close it\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.MCPAdapt.atools","title":"atools","text":"<pre><code>atools() -&gt; list[Any]\n</code></pre> <p>Returns the tools from the MCP server adapted to the desired Agent framework.</p> <p>This is what is yielded if used as an async context manager otherwise you can access it directly via this method.</p> <p>An equivalent async method is available if your Agent framework supports it: see :meth:<code>atools</code>.</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>def atools(self) -&gt; list[Any]:\n    \"\"\"Returns the tools from the MCP server adapted to the desired Agent framework.\n\n    This is what is yielded if used as an async context manager otherwise you can\n    access it directly via this method.\n\n    An equivalent async method is available if your Agent framework supports it:\n    see :meth:`atools`.\n    \"\"\"\n    return [\n        self.adapter.async_adapt(partial(self.session.call_tool, tool.name), tool)\n        for tool in self.mcp_tools\n    ]\n</code></pre>"},{"location":"ref/core/#mcpadapt.core.mcptools","title":"mcptools  <code>async</code>","text":"<pre><code>mcptools(\n    serverparams: StdioServerParameters | dict[str, Any],\n) -&gt; tuple[ClientSession, list[Tool]]\n</code></pre> <p>Async context manager that yields tools from an MCP server.</p> <p>Note: the session can be then used to call tools on the MCP server but it's async. Use MCPAdapt instead if you need to use the tools synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>serverparams</code> <code>StdioServerParameters | dict[str, Any]</code> <p>Parameters passed to either the stdio client or sse client. * if StdioServerParameters, run the MCP server using the stdio protocol. * if dict, assume the dict corresponds to parameters to an sse MCP server.</p> required <p>Yields:</p> Type Description <code>tuple[ClientSession, list[Tool]]</code> <p>A list of tools available on the MCP server.</p> <p>Usage:</p> <p>async with mcptools(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"])) as (session, tools):     print(tools)</p> Source code in <code>src/mcpadapt/core.py</code> <pre><code>@asynccontextmanager\nasync def mcptools(\n    serverparams: StdioServerParameters | dict[str, Any],\n) -&gt; tuple[ClientSession, list[mcp.types.Tool]]:\n    \"\"\"Async context manager that yields tools from an MCP server.\n\n    Note: the session can be then used to call tools on the MCP server but it's async.\n    Use MCPAdapt instead if you need to use the tools synchronously.\n\n    Args:\n        serverparams: Parameters passed to either the stdio client or sse client.\n            * if StdioServerParameters, run the MCP server using the stdio protocol.\n            * if dict, assume the dict corresponds to parameters to an sse MCP server.\n\n    Yields:\n        A list of tools available on the MCP server.\n\n    Usage:\n    &gt;&gt;&gt; async with mcptools(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"])) as (session, tools):\n    &gt;&gt;&gt;     print(tools)\n    \"\"\"\n    if isinstance(serverparams, StdioServerParameters):\n        client = stdio_client(serverparams)\n    elif isinstance(serverparams, dict):\n        client = sse_client(**serverparams)\n    else:\n        raise ValueError(\n            f\"Invalid serverparams, expected StdioServerParameters or dict found `{type(serverparams)}`\"\n        )\n\n    async with client as (read, write):\n        async with ClientSession(read, write) as session:\n            # Initialize the connection and get the tools from the mcp server\n            await session.initialize()\n            tools = await session.list_tools()\n            yield session, tools.tools\n</code></pre>"},{"location":"ref/crewai_adapter/","title":"<code>CrewAI Adapter</code>","text":"<p>This module implements the CrewAI adapter.</p> <p>CrewAI tools support only sync functions for their tools.</p> <p>Example Usage:</p> <p>with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), CrewAIAdapter()) as tools:     print(tools)</p>"},{"location":"ref/crewai_adapter/#mcpadapt.crewai_adapter.CrewAIAdapter","title":"CrewAIAdapter","text":"<p>               Bases: <code>ToolAdapter</code></p> <p>Adapter for <code>crewai</code>.</p> <p>Note that <code>crewai</code> support only sync tools so we write adapt for sync tools only.</p> <p>Warning: if the mcp tool name is a python keyword, starts with digits or contains dashes, the tool name will be sanitized to become a valid python function name.</p> Source code in <code>src/mcpadapt/crewai_adapter.py</code> <pre><code>class CrewAIAdapter(ToolAdapter):\n    \"\"\"Adapter for `crewai`.\n\n    Note that `crewai` support only sync tools so we write adapt for sync tools only.\n\n    Warning: if the mcp tool name is a python keyword, starts with digits or contains\n    dashes, the tool name will be sanitized to become a valid python function name.\n\n    \"\"\"\n\n    def adapt(\n        self,\n        func: Callable[[dict | None], mcp.types.CallToolResult],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; BaseTool:\n        \"\"\"Adapt a MCP tool to a CrewAI tool.\n\n        Args:\n            func: The function to adapt.\n            mcp_tool: The MCP tool to adapt.\n\n        Returns:\n            A CrewAI tool.\n        \"\"\"\n        ToolInput = create_model_from_json_schema(mcp_tool.inputSchema)\n\n        class CrewAIMCPTool(BaseTool):\n            name: str = mcp_tool.name\n            description: str = mcp_tool.description or \"\"\n            args_schema: Type[BaseModel] = ToolInput\n\n            def _run(self, *args: Any, **kwargs: Any) -&gt; Any:\n                print(\"args\", args)\n                print(\"kwargs\", kwargs)\n                return func(kwargs).content[0].text  # type: ignore\n\n            def _generate_description(self):\n                args_schema = {\n                    k: v\n                    for k, v in jsonref.replace_refs(\n                        self.args_schema.model_json_schema()\n                    ).items()\n                    if k != \"$defs\"\n                }\n                self.description = f\"Tool Name: {self.name}\\nTool Arguments: {args_schema}\\nTool Description: {self.description}\"\n\n        return CrewAIMCPTool()\n\n    async def async_adapt(\n        self,\n        afunc: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; Any:\n        raise NotImplementedError(\"async is not supported by the CrewAI framework.\")\n</code></pre>"},{"location":"ref/crewai_adapter/#mcpadapt.crewai_adapter.CrewAIAdapter.adapt","title":"adapt","text":"<pre><code>adapt(\n    func: Callable[[dict | None], CallToolResult],\n    mcp_tool: Tool,\n) -&gt; BaseTool\n</code></pre> <p>Adapt a MCP tool to a CrewAI tool.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict | None], CallToolResult]</code> <p>The function to adapt.</p> required <code>mcp_tool</code> <code>Tool</code> <p>The MCP tool to adapt.</p> required <p>Returns:</p> Type Description <code>BaseTool</code> <p>A CrewAI tool.</p> Source code in <code>src/mcpadapt/crewai_adapter.py</code> <pre><code>def adapt(\n    self,\n    func: Callable[[dict | None], mcp.types.CallToolResult],\n    mcp_tool: mcp.types.Tool,\n) -&gt; BaseTool:\n    \"\"\"Adapt a MCP tool to a CrewAI tool.\n\n    Args:\n        func: The function to adapt.\n        mcp_tool: The MCP tool to adapt.\n\n    Returns:\n        A CrewAI tool.\n    \"\"\"\n    ToolInput = create_model_from_json_schema(mcp_tool.inputSchema)\n\n    class CrewAIMCPTool(BaseTool):\n        name: str = mcp_tool.name\n        description: str = mcp_tool.description or \"\"\n        args_schema: Type[BaseModel] = ToolInput\n\n        def _run(self, *args: Any, **kwargs: Any) -&gt; Any:\n            print(\"args\", args)\n            print(\"kwargs\", kwargs)\n            return func(kwargs).content[0].text  # type: ignore\n\n        def _generate_description(self):\n            args_schema = {\n                k: v\n                for k, v in jsonref.replace_refs(\n                    self.args_schema.model_json_schema()\n                ).items()\n                if k != \"$defs\"\n            }\n            self.description = f\"Tool Name: {self.name}\\nTool Arguments: {args_schema}\\nTool Description: {self.description}\"\n\n    return CrewAIMCPTool()\n</code></pre>"},{"location":"ref/google_genai_adapter/","title":"<code>Google GenAI Adapter</code>","text":"<p>This module implements the Google GenAI adapter.</p> <p>Example Usage:</p> <p>with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), GoogleGenAIAdapter()) as tools:     print(tools)</p>"},{"location":"ref/google_genai_adapter/#mcpadapt.google_genai_adapter.GoogleGenAIAdapter","title":"GoogleGenAIAdapter","text":"<p>               Bases: <code>ToolAdapter</code></p> <p>Adapter for the <code>google.genai</code> package.</p> <p>Note that the <code>google.genai</code> package do not support async tools at this time so we write only the adapt method.</p> Source code in <code>src/mcpadapt/google_genai_adapter.py</code> <pre><code>class GoogleGenAIAdapter(ToolAdapter):\n    \"\"\"Adapter for the `google.genai` package.\n\n    Note that the `google.genai` package do not support async tools at this time so we\n    write only the adapt method.\n    \"\"\"\n\n    def adapt(\n        self,\n        func: Callable[[dict | None], mcp.types.CallToolResult],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; tuple[\n        types.Tool, tuple[str, Callable[[dict | None], mcp.types.CallToolResult]]\n    ]:\n        \"\"\"Adapt a MCP tool to a Google GenAI tool.\n\n        Args:\n            func: The function to adapt.\n            mcp_tool: The MCP tool to adapt.\n\n        Returns:\n            A Google GenAI tool.\n        \"\"\"\n        # make sure jsonref are resolved\n        input_schema = {\n            k: v\n            for k, v in jsonref.replace_refs(mcp_tool.inputSchema).items()\n            if k != \"$defs\"\n        }\n\n        return (\n            types.Tool(\n                function_declarations=[\n                    {\n                        \"name\": mcp_tool.name,\n                        \"description\": mcp_tool.description,\n                        \"parameters\": input_schema,\n                    }\n                ],\n            ),\n            (mcp_tool.name, func),\n        )\n\n    def async_adapt(\n        self,\n        func: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; tuple[\n        types.Tool,\n        tuple[\n            str, Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]]\n        ],\n    ]:\n        \"\"\"Adapt a MCP tool to a Google GenAI tool.\n\n        Args:\n            func: The function to adapt.\n            mcp_tool: The MCP tool to adapt.\n\n        Returns:\n            A Google GenAI tool.\n        \"\"\"\n        # make sure jsonref are resolved\n        input_schema = {\n            k: v\n            for k, v in jsonref.replace_refs(mcp_tool.inputSchema).items()\n            if k != \"$defs\"\n        }\n\n        return (\n            types.Tool(\n                function_declarations=[\n                    {\n                        \"name\": mcp_tool.name,\n                        \"description\": mcp_tool.description,\n                        \"parameters\": input_schema,\n                    }\n                ],\n            ),\n            (mcp_tool.name, func),\n        )\n</code></pre>"},{"location":"ref/google_genai_adapter/#mcpadapt.google_genai_adapter.GoogleGenAIAdapter.adapt","title":"adapt","text":"<pre><code>adapt(\n    func: Callable[[dict | None], CallToolResult],\n    mcp_tool: Tool,\n) -&gt; tuple[\n    Tool,\n    tuple[str, Callable[[dict | None], CallToolResult]],\n]\n</code></pre> <p>Adapt a MCP tool to a Google GenAI tool.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict | None], CallToolResult]</code> <p>The function to adapt.</p> required <code>mcp_tool</code> <code>Tool</code> <p>The MCP tool to adapt.</p> required <p>Returns:</p> Type Description <code>tuple[Tool, tuple[str, Callable[[dict | None], CallToolResult]]]</code> <p>A Google GenAI tool.</p> Source code in <code>src/mcpadapt/google_genai_adapter.py</code> <pre><code>def adapt(\n    self,\n    func: Callable[[dict | None], mcp.types.CallToolResult],\n    mcp_tool: mcp.types.Tool,\n) -&gt; tuple[\n    types.Tool, tuple[str, Callable[[dict | None], mcp.types.CallToolResult]]\n]:\n    \"\"\"Adapt a MCP tool to a Google GenAI tool.\n\n    Args:\n        func: The function to adapt.\n        mcp_tool: The MCP tool to adapt.\n\n    Returns:\n        A Google GenAI tool.\n    \"\"\"\n    # make sure jsonref are resolved\n    input_schema = {\n        k: v\n        for k, v in jsonref.replace_refs(mcp_tool.inputSchema).items()\n        if k != \"$defs\"\n    }\n\n    return (\n        types.Tool(\n            function_declarations=[\n                {\n                    \"name\": mcp_tool.name,\n                    \"description\": mcp_tool.description,\n                    \"parameters\": input_schema,\n                }\n            ],\n        ),\n        (mcp_tool.name, func),\n    )\n</code></pre>"},{"location":"ref/google_genai_adapter/#mcpadapt.google_genai_adapter.GoogleGenAIAdapter.async_adapt","title":"async_adapt","text":"<pre><code>async_adapt(\n    func: Callable[\n        [dict | None], Coroutine[Any, Any, CallToolResult]\n    ],\n    mcp_tool: Tool,\n) -&gt; tuple[\n    Tool,\n    tuple[\n        str,\n        Callable[\n            [dict | None],\n            Coroutine[Any, Any, CallToolResult],\n        ],\n    ],\n]\n</code></pre> <p>Adapt a MCP tool to a Google GenAI tool.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict | None], Coroutine[Any, Any, CallToolResult]]</code> <p>The function to adapt.</p> required <code>mcp_tool</code> <code>Tool</code> <p>The MCP tool to adapt.</p> required <p>Returns:</p> Type Description <code>tuple[Tool, tuple[str, Callable[[dict | None], Coroutine[Any, Any, CallToolResult]]]]</code> <p>A Google GenAI tool.</p> Source code in <code>src/mcpadapt/google_genai_adapter.py</code> <pre><code>def async_adapt(\n    self,\n    func: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n    mcp_tool: mcp.types.Tool,\n) -&gt; tuple[\n    types.Tool,\n    tuple[\n        str, Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]]\n    ],\n]:\n    \"\"\"Adapt a MCP tool to a Google GenAI tool.\n\n    Args:\n        func: The function to adapt.\n        mcp_tool: The MCP tool to adapt.\n\n    Returns:\n        A Google GenAI tool.\n    \"\"\"\n    # make sure jsonref are resolved\n    input_schema = {\n        k: v\n        for k, v in jsonref.replace_refs(mcp_tool.inputSchema).items()\n        if k != \"$defs\"\n    }\n\n    return (\n        types.Tool(\n            function_declarations=[\n                {\n                    \"name\": mcp_tool.name,\n                    \"description\": mcp_tool.description,\n                    \"parameters\": input_schema,\n                }\n            ],\n        ),\n        (mcp_tool.name, func),\n    )\n</code></pre>"},{"location":"ref/langchain_adapter/","title":"<code>Langchain Adapter</code>","text":"<p>This module implements the LangChain adapter.</p> <p>LangChain tools support both sync and async functions for their tools so we can leverage both in our implementation.</p> <p>Example Usage:</p> <p>with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), LangChainAdapter()) as tools:     print(tools)</p>"},{"location":"ref/langchain_adapter/#mcpadapt.langchain_adapter.LangChainAdapter","title":"LangChainAdapter","text":"<p>               Bases: <code>ToolAdapter</code></p> <p>Adapter for <code>langchain</code>.</p> <p>Note that <code>langchain</code> support both sync and async tools so we write adapt for both methods.</p> <p>Warning: if the mcp tool name is a python keyword, starts with digits or contains dashes, the tool name will be sanitized to become a valid python function name.</p> Source code in <code>src/mcpadapt/langchain_adapter.py</code> <pre><code>class LangChainAdapter(ToolAdapter):\n    \"\"\"Adapter for `langchain`.\n\n    Note that `langchain` support both sync and async tools so we\n    write adapt for both methods.\n\n    Warning: if the mcp tool name is a python keyword, starts with digits or contains\n    dashes, the tool name will be sanitized to become a valid python function name.\n\n    \"\"\"\n\n    def adapt(\n        self,\n        func: Callable[[dict | None], mcp.types.CallToolResult],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; BaseTool:\n        \"\"\"Adapt a MCP tool to a LangChain tool.\n\n        Args:\n            func: The function to adapt.\n            mcp_tool: The MCP tool to adapt.\n\n        Returns:\n            A LangChain tool.\n        \"\"\"\n        mcp_tool_name = _sanitize_function_name(mcp_tool.name)\n\n        generate_class_template = partial(\n            _generate_tool_class,\n            mcp_tool_name,\n            mcp_tool.description,\n            mcp_tool.inputSchema,\n            False,\n        )\n        return _instanciate_tool(mcp_tool_name, generate_class_template, func)\n\n    def async_adapt(\n        self,\n        afunc: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; BaseTool:\n        \"\"\"Adapt a MCP tool to a LangChain tool.\n\n        Args:\n            afunc: The function to adapt.\n            mcp_tool: The MCP tool to adapt.\n\n        Returns:\n            A LangChain tool.\n        \"\"\"\n        mcp_tool_name = _sanitize_function_name(mcp_tool.name)\n        if mcp_tool_name != mcp_tool.name:\n            log.warning(f\"MCP tool name {mcp_tool.name} sanitized to {mcp_tool_name}\")\n\n        generate_class_template = partial(\n            _generate_tool_class,\n            mcp_tool_name,\n            mcp_tool.description,\n            mcp_tool.inputSchema,\n            True,\n        )\n        return _instanciate_tool(mcp_tool_name, generate_class_template, afunc)\n</code></pre>"},{"location":"ref/langchain_adapter/#mcpadapt.langchain_adapter.LangChainAdapter.adapt","title":"adapt","text":"<pre><code>adapt(\n    func: Callable[[dict | None], CallToolResult],\n    mcp_tool: Tool,\n) -&gt; BaseTool\n</code></pre> <p>Adapt a MCP tool to a LangChain tool.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict | None], CallToolResult]</code> <p>The function to adapt.</p> required <code>mcp_tool</code> <code>Tool</code> <p>The MCP tool to adapt.</p> required <p>Returns:</p> Type Description <code>BaseTool</code> <p>A LangChain tool.</p> Source code in <code>src/mcpadapt/langchain_adapter.py</code> <pre><code>def adapt(\n    self,\n    func: Callable[[dict | None], mcp.types.CallToolResult],\n    mcp_tool: mcp.types.Tool,\n) -&gt; BaseTool:\n    \"\"\"Adapt a MCP tool to a LangChain tool.\n\n    Args:\n        func: The function to adapt.\n        mcp_tool: The MCP tool to adapt.\n\n    Returns:\n        A LangChain tool.\n    \"\"\"\n    mcp_tool_name = _sanitize_function_name(mcp_tool.name)\n\n    generate_class_template = partial(\n        _generate_tool_class,\n        mcp_tool_name,\n        mcp_tool.description,\n        mcp_tool.inputSchema,\n        False,\n    )\n    return _instanciate_tool(mcp_tool_name, generate_class_template, func)\n</code></pre>"},{"location":"ref/langchain_adapter/#mcpadapt.langchain_adapter.LangChainAdapter.async_adapt","title":"async_adapt","text":"<pre><code>async_adapt(\n    afunc: Callable[\n        [dict | None], Coroutine[Any, Any, CallToolResult]\n    ],\n    mcp_tool: Tool,\n) -&gt; BaseTool\n</code></pre> <p>Adapt a MCP tool to a LangChain tool.</p> <p>Parameters:</p> Name Type Description Default <code>afunc</code> <code>Callable[[dict | None], Coroutine[Any, Any, CallToolResult]]</code> <p>The function to adapt.</p> required <code>mcp_tool</code> <code>Tool</code> <p>The MCP tool to adapt.</p> required <p>Returns:</p> Type Description <code>BaseTool</code> <p>A LangChain tool.</p> Source code in <code>src/mcpadapt/langchain_adapter.py</code> <pre><code>def async_adapt(\n    self,\n    afunc: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n    mcp_tool: mcp.types.Tool,\n) -&gt; BaseTool:\n    \"\"\"Adapt a MCP tool to a LangChain tool.\n\n    Args:\n        afunc: The function to adapt.\n        mcp_tool: The MCP tool to adapt.\n\n    Returns:\n        A LangChain tool.\n    \"\"\"\n    mcp_tool_name = _sanitize_function_name(mcp_tool.name)\n    if mcp_tool_name != mcp_tool.name:\n        log.warning(f\"MCP tool name {mcp_tool.name} sanitized to {mcp_tool_name}\")\n\n    generate_class_template = partial(\n        _generate_tool_class,\n        mcp_tool_name,\n        mcp_tool.description,\n        mcp_tool.inputSchema,\n        True,\n    )\n    return _instanciate_tool(mcp_tool_name, generate_class_template, afunc)\n</code></pre>"},{"location":"ref/smolagents_adapter/","title":"<code>Smolagents Adapter</code>","text":"<p>This module implements the SmolAgents adapter.</p> <p>SmolAgents do not support async tools, so this adapter will only work with the sync context manager.</p> <p>Example Usage:</p> <p>with MCPAdapt(StdioServerParameters(command=\"uv\", args=[\"run\", \"src/echo.py\"]), SmolAgentAdapter()) as tools:     print(tools)</p>"},{"location":"ref/smolagents_adapter/#mcpadapt.smolagents_adapter.SmolAgentsAdapter","title":"SmolAgentsAdapter","text":"<p>               Bases: <code>ToolAdapter</code></p> <p>Adapter for the <code>smolagents</code> framework.</p> <p>Note that the <code>smolagents</code> framework do not support async tools at this time so we write only the adapt method.</p> Source code in <code>src/mcpadapt/smolagents_adapter.py</code> <pre><code>class SmolAgentsAdapter(ToolAdapter):\n    \"\"\"Adapter for the `smolagents` framework.\n\n    Note that the `smolagents` framework do not support async tools at this time so we\n    write only the adapt method.\n    \"\"\"\n\n    def adapt(\n        self,\n        func: Callable[[dict | None], mcp.types.CallToolResult],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; smolagents.Tool:\n        \"\"\"Adapt a MCP tool to a SmolAgents tool.\n\n        Args:\n            func: The function to adapt.\n            mcp_tool: The MCP tool to adapt.\n\n        Returns:\n            A SmolAgents tool.\n        \"\"\"\n\n        class MCPAdaptTool(smolagents.Tool):\n            def __init__(\n                self,\n                name: str,\n                description: str,\n                inputs: dict[str, dict[str, str]],\n                output_type: str,\n            ):\n                self.name = name\n                self.description = description\n                self.inputs = inputs\n                self.output_type = output_type\n                self.is_initialized = True\n                self.skip_forward_signature_validation = True\n\n            def forward(self, *args, **kwargs) -&gt; str:\n                if len(args) &gt; 0:\n                    if len(args) == 1 and isinstance(args[0], dict) and not kwargs:\n                        mcp_output = func(args[0])\n                    else:\n                        raise ValueError(\n                            f\"tool {self.name} does not support multiple positional arguments or combined positional and keyword arguments\"\n                        )\n                else:\n                    mcp_output = func(kwargs)\n\n                if len(mcp_output.content) == 0:\n                    raise ValueError(f\"tool {self.name} returned an empty content\")\n\n                if len(mcp_output.content) &gt; 1:\n                    logger.warning(\n                        f\"tool {self.name} returned multiple content, using the first one\"\n                    )\n\n                if not isinstance(mcp_output.content[0], mcp.types.TextContent):\n                    raise ValueError(\n                        f\"tool {self.name} returned a non-text content: `{type(mcp_output.content[0])}`\"\n                    )\n\n                return mcp_output.content[0].text  # type: ignore\n\n        # make sure jsonref are resolved\n        input_schema = {\n            k: v\n            for k, v in jsonref.replace_refs(mcp_tool.inputSchema).items()\n            if k != \"$defs\"\n        }\n\n        # make sure mandatory `description` and `type` is provided for each arguments:\n        for k, v in input_schema[\"properties\"].items():\n            if \"description\" not in v:\n                input_schema[\"properties\"][k][\"description\"] = \"see tool description\"\n            if \"type\" not in v:\n                input_schema[\"properties\"][k][\"type\"] = \"string\"\n\n        tool = MCPAdaptTool(\n            name=mcp_tool.name,\n            description=mcp_tool.description or \"\",\n            inputs=input_schema[\"properties\"],\n            output_type=\"string\",\n        )\n\n        return tool\n\n    async def async_adapt(\n        self,\n        afunc: Callable[[dict | None], Coroutine[Any, Any, mcp.types.CallToolResult]],\n        mcp_tool: mcp.types.Tool,\n    ) -&gt; smolagents.Tool:\n        raise NotImplementedError(\"async is not supported by the SmolAgents framework.\")\n</code></pre>"},{"location":"ref/smolagents_adapter/#mcpadapt.smolagents_adapter.SmolAgentsAdapter.adapt","title":"adapt","text":"<pre><code>adapt(\n    func: Callable[[dict | None], CallToolResult],\n    mcp_tool: Tool,\n) -&gt; Tool\n</code></pre> <p>Adapt a MCP tool to a SmolAgents tool.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict | None], CallToolResult]</code> <p>The function to adapt.</p> required <code>mcp_tool</code> <code>Tool</code> <p>The MCP tool to adapt.</p> required <p>Returns:</p> Type Description <code>Tool</code> <p>A SmolAgents tool.</p> Source code in <code>src/mcpadapt/smolagents_adapter.py</code> <pre><code>def adapt(\n    self,\n    func: Callable[[dict | None], mcp.types.CallToolResult],\n    mcp_tool: mcp.types.Tool,\n) -&gt; smolagents.Tool:\n    \"\"\"Adapt a MCP tool to a SmolAgents tool.\n\n    Args:\n        func: The function to adapt.\n        mcp_tool: The MCP tool to adapt.\n\n    Returns:\n        A SmolAgents tool.\n    \"\"\"\n\n    class MCPAdaptTool(smolagents.Tool):\n        def __init__(\n            self,\n            name: str,\n            description: str,\n            inputs: dict[str, dict[str, str]],\n            output_type: str,\n        ):\n            self.name = name\n            self.description = description\n            self.inputs = inputs\n            self.output_type = output_type\n            self.is_initialized = True\n            self.skip_forward_signature_validation = True\n\n        def forward(self, *args, **kwargs) -&gt; str:\n            if len(args) &gt; 0:\n                if len(args) == 1 and isinstance(args[0], dict) and not kwargs:\n                    mcp_output = func(args[0])\n                else:\n                    raise ValueError(\n                        f\"tool {self.name} does not support multiple positional arguments or combined positional and keyword arguments\"\n                    )\n            else:\n                mcp_output = func(kwargs)\n\n            if len(mcp_output.content) == 0:\n                raise ValueError(f\"tool {self.name} returned an empty content\")\n\n            if len(mcp_output.content) &gt; 1:\n                logger.warning(\n                    f\"tool {self.name} returned multiple content, using the first one\"\n                )\n\n            if not isinstance(mcp_output.content[0], mcp.types.TextContent):\n                raise ValueError(\n                    f\"tool {self.name} returned a non-text content: `{type(mcp_output.content[0])}`\"\n                )\n\n            return mcp_output.content[0].text  # type: ignore\n\n    # make sure jsonref are resolved\n    input_schema = {\n        k: v\n        for k, v in jsonref.replace_refs(mcp_tool.inputSchema).items()\n        if k != \"$defs\"\n    }\n\n    # make sure mandatory `description` and `type` is provided for each arguments:\n    for k, v in input_schema[\"properties\"].items():\n        if \"description\" not in v:\n            input_schema[\"properties\"][k][\"description\"] = \"see tool description\"\n        if \"type\" not in v:\n            input_schema[\"properties\"][k][\"type\"] = \"string\"\n\n    tool = MCPAdaptTool(\n        name=mcp_tool.name,\n        description=mcp_tool.description or \"\",\n        inputs=input_schema[\"properties\"],\n        output_type=\"string\",\n    )\n\n    return tool\n</code></pre>"}]}